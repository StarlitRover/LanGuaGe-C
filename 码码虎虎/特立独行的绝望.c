/*7-7 特立独行的幸福 (10分)
对一个十进制数的各位数字做一次平方和，称作一次迭代。如果一个十进制数能通过若干次迭代得到 1，就称该数为幸福数。1 是一个幸福数。
此外，例如 19 经过 1 次迭代得到 82，2 次迭代后得到 68，3 次迭代后得到 100，最后得到 1。则 19 就是幸福数。显然，在一个幸福数
迭代到 1 的过程中经过的数字都是幸福数，它们的幸福是依附于初始数字的。例如 82、68、100 的幸福是依附于 19 的。而一个特立独行的
幸福数，是在一个有限的区间内不依附于任何其它数字的；其独立性就是依附于它的的幸福数的个数。如果这个数还是个素数，则其独立性加倍。
例如 19 在区间[1, 100] 内就是一个特立独行的幸福数，其独立性为 2×4=8。

另一方面，如果一个大于1的数字经过数次迭代后进入了死循环，那这个数就不幸福。例如 29 迭代得到 85、89、145、42、20、4、16、37、58、89、…… 
可见 89 到 58 形成了死循环，所以 29 就不幸福。

本题就要求你编写程序，列出给定区间内的所有特立独行的幸福数和它的独立性。

输入格式：
输入在第一行给出闭区间的两个端点：1<A<B≤10^4.

输出格式：
按递增顺序列出给定闭区间 [A,B] 内的所有特立独行的幸福数和它的独立性。每对数字占一行，数字间以 1 个空格分隔。
如果区间内没有幸福数，则在一行中输出 SAD。

输入样例 1：
10 40

输出样例 1：
19 8
23 6
28 3
31 4
32 3
注意：样例中，10、13 也都是幸福数，但它们分别依附于其他数字（如 23、31 等等），所以不输出。其它数字虽然其实也依附于其它幸福数，
但因为那些数字不在给定区间 [10, 40] 内，所以它们在给定区间内是特立独行的幸福数。

输入样例 2：
110 120
输出样例 2：
SAD*/
#include<stdio.h>
#include<math.h>
int judge(int x);
int main() {
    int m, n, sum, cnt, flag, sign = 1, w = 0;
    scanf("%d%d", &m, &n);
    int s[n-m+1];
    for(int i = 0; i < n-m+1; ++i)
    	s[i] = 1;                                                  //设立数组是为了(以归0的方式)标记依附的数
    for (int i = m; i <= n; ++i) 
    {
        if (!s[i-m]) continue;                                 //这里保证了归0的数(即依附的数)不进入循环
        int k = i;
        cnt = 0;
        sum = k;
        flag = 1;
        while(sum != 1) 
        {
            if (sum == 4)                                       //4在此便成为拦截循环通过的一个路障了
            {
                flag = 0;
				break;
            }
            k = sum;
            sum = 0;
            if(cnt && k >= m && k <= n) s[k-m] = 0;             //这里所有数([m,n])在迭代路上历经的所有在范围内的数(即依附的数)都抹去了(即归0)
            while(k) 
            {
                sum += pow(k%10, 2);
                k /= 10;
            }
            ++cnt;
        }
        if (flag)
		{
            s[i-m] = cnt; 
			sign = 0;
		}                              //数组还可以记录一个幸福数的独立性
        else 
			s[i-m] = 0;
    }
    if(sign) 
		printf("SAD");
    else
		for (int i = 0; i < n-m+1; ++i) 
		    if(s[i]) 
		    {
		        if(w) printf("\n");                                  //w的存在是为了检测该数是否是输出的第一个数
		        printf("%d %d", i+m, (judge(i+m)+1)*s[i]);           //Judge函数返回0or1的缘由
		        w = 1;
		    }
    return 0;
}
int judge(int x)                         //判断是否为素数的Judge函数
{
    int judge = 0, flag = 1;
    for(int j = 2; j <= sqrt(x); ++j)
    if(x%j == 0) {
        flag = 0; break;
    }
    if(flag && x > 1) judge = 1;
    return judge;
}
/*这题目最大的难点就在于如何判断这个数不是幸福数,接下来我就说一下我的心路历程吧:
首先我考虑了四位以内数经过有限次的迭代是否都会变为两位数，答案是肯定的且不难证明.于是我开始考虑100以内的幸福数.
我编了一段可以输出数字迭代过程的代码(*)，然后将100以内所有的幸福数都找了出来，而在操作的过程中我又发现了一个有趣的
现象:所有的不幸福数都会历经4这个数字.于是乎又给我提供了检验不幸福数的灵感，毕竟直接用代码去检查一个数的迭代
过程是否陷入了循环并不是一件容易的事.至于这个4必然出现的本质原因我猜想可能是因为这条循环链在迭代中是唯一存在的.*/
//(*)
#include<stdio.h>
#include<math.h>
int main() 
{
    int n, sum, cnt = 0;

    scanf("%d", &n);
    sum = n;
    while(sum != 1) 
    {
        n = sum;
        sum = 0;
        while(n) 
        {
            sum += pow(n%10, 2);
            n /= 10;
        }
        if(++cnt > 20) break;
        printf("~%d\n", sum);
    }
    return 0;
}

//Seek Max Chain
#include<stdio.h>
#include<math.h>
int main() 
{
    int cnt,max=0,k,sign,sum;
    for(int i=2;i<100;++i)
    {
        cnt=0;
        sum=k=i;
        while(sum!=4)
        {
            sum=0;
        while (k)
            {
            sum+=pow(k%10,2);
            k/=10;
            }
            if (sum==1) {cnt=0;break;}
            ++cnt;
            k=sum;
        }
        if(max<cnt) {max=cnt;sign=i;}
    }
    printf("%d",sign);
    return 0;
}                                            //outcome:88
